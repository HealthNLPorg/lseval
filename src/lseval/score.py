import logging
from collections import defaultdict
from itertools import chain
from operator import attrgetter

from .correctness_matrix import CorrectnessMatrix
from .datatypes import (
    Entity,
    Relation,
    overlap_match,
)

logger = logging.getLogger(__name__)

logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(name)s -   %(message)s",
    datefmt="%m/%d/%Y %H:%M:%S",
    level=logging.INFO,
)


# Assume that the entity subtype here is fixed
# in Java would use <T extends Entity> ... set[T] ... set[T]
# the __eq__ method automatically generated by @dataclass
# would let us filter on the subtypes but still
# think that's easier to keep outside the library
def build_entity_correctness_matrix(
    predicted_entities: set[Entity], reference_entities: set[Entity], overlap: bool
) -> CorrectnessMatrix:
    if overlap:
        return overlap_entity_correctness_matrix(predicted_entities, reference_entities)
    return exact_entity_correctness_matrix(predicted_entities, reference_entities)


def overlap_entity_correctness_matrix(
    predicted_entities: set[Entity], reference_entities: set[Entity]
) -> CorrectnessMatrix:
    reference_span_to_entities = defaultdict(list)
    for entity in reference_entities:
        reference_span_to_entities[entity.span].append(entity)

    for span, entities in reference_span_to_entities.items():
        if len(entities) > 1:
            logger.warning(
                "%s reference entities from %d share the span %s",
                ", ".join(sorted(map(attrgetter("label_studio_id"), entities))),
                entities[0].file_id,
                str(span),
            )

    predicted_span_to_entities = defaultdict(list)
    for entity in predicted_entities:
        predicted_span_to_entities[entity.span].append(entity)

    for span, entities in predicted_span_to_entities.items():
        if len(entities) > 1:
            logger.warning(
                "%s predicted entities from %d share the span %s",
                ", ".join(sorted(map(attrgetter("label_studio_id"), entities))),
                entities[0].file_id,
                str(span),
            )
    sorted_reference_spans = sorted(reference_span_to_entities.keys())
    sorted_predicted_spans = sorted(predicted_span_to_entities.keys())
    true_positive_entities = set()
    false_positive_entities = set()
    false_negative_entities = set()
    # This is still kind of brute force but at least this
    # is a reasonably Pythonic draft
    # designing a nicer algorithm for this
    # seems to have some weird time/memory
    # tradeoffs and is probably only worth it for
    # a ton of intervals with a lot of interval intersections
    # The wrinkle being overlapping is not an equivalence
    # relation.  I.e. is reflexive and symmetric but not transitive
    for span, entities in predicted_span_to_entities.items():
        if any(overlap_match(span, ref_span) for ref_span in sorted_reference_spans):
            true_positive_entities.update(entities)
        else:
            false_positive_entities.update(entities)
    for span, entities in reference_span_to_entities.items():
        if any(overlap_match(span, pred_span) for pred_span in sorted_predicted_spans):
            continue
        false_negative_entities.update(entities)

    return CorrectnessMatrix(
        true_positives=true_positive_entities,
        false_positives=false_positive_entities,
        false_negatives=false_negative_entities,
    )


def exact_entity_correctness_matrix(
    predicted_entities: set[Entity], reference_entities: set[Entity]
) -> CorrectnessMatrix:
    # want to keep this span level due to the extension logic, can re-work it later
    reference_span_to_entities = defaultdict(list)
    for entity in reference_entities:
        reference_span_to_entities[entity.span].append(entity)

    for span, entities in reference_span_to_entities.items():
        if len(entities) > 1:
            logger.warning(
                "%s reference entities from %d share the span %s",
                ", ".join(sorted(map(attrgetter("label_studio_id"), entities))),
                entities[0].file_id,
                str(span),
            )

    predicted_span_to_entities = defaultdict(list)
    for entity in predicted_entities:
        predicted_span_to_entities[entity.span].append(entity)

    for span, entities in predicted_span_to_entities.items():
        if len(entities) > 1:
            logger.warning(
                "%s predicted entities from %d share the span %s",
                ", ".join(sorted(map(attrgetter("label_studio_id"), entities))),
                entities[0].file_id,
                str(span),
            )
    true_positive_entities = set(
        chain.from_iterable(
            predicted_span_to_entities.get(predicted_span, [])
            for predicted_span in reference_span_to_entities.keys()
            & predicted_span_to_entities.keys()
        )
    )

    false_positive_entities = set(
        chain.from_iterable(
            predicted_span_to_entities.get(predicted_span, [])
            for predicted_span in predicted_span_to_entities.keys()
            - reference_span_to_entities.keys()
        )
    )
    false_negative_entities = set(
        chain.from_iterable(
            reference_span_to_entities.get(predicted_span, [])
            for predicted_span in reference_span_to_entities.keys()
            - predicted_span_to_entities.keys()
        )
    )
    return CorrectnessMatrix(
        true_positives=true_positive_entities,
        false_positives=false_positive_entities,
        false_negatives=false_negative_entities,
    )


# Whether or not "None"s are considered
# is left up to the user
def build_relation_correctness_matrix(
    predicted_relations: list[Relation],
    reference_relations: list[Relation],
    overlap: bool,
) -> CorrectnessMatrix:
    if not overlap:
        return exact_relation_correctness_matrix(
            predicted_relations, reference_relations
        )
    return overlap_relation_correctness_matrix(predicted_relations, reference_relations)


def exact_relation_correctness_matrix(
    predicted_relations: list[Relation], reference_relations: list[Relation]
) -> CorrectnessMatrix:
    predicted_set = set(predicted_relations)
    assert len(predicted_set) == len(predicted_relations)
    reference_set = set(reference_relations)
    assert len(reference_set) == len(reference_relations)
    return CorrectnessMatrix(
        true_positives=predicted_set & reference_set,
        false_positives=predicted_set - reference_set,
        false_negatives=reference_set - predicted_set,
    )


def overlap_relation_correctness_matrix(
    predicted_relations: list[Relation], reference_relations: list[Relation]
) -> CorrectnessMatrix:
    true_positives = set()
    false_positives = set()
    false_negatives = set()
    for prediction in predicted_relations:
        if any(
            prediction.overlap_match(reference) for reference in reference_relations
        ):
            true_positives.add(prediction)
        else:
            false_positives.add(prediction)
    for reference in reference_relations:
        if any(
            reference.overlap_match(prediction) for prediction in predicted_relations
        ):
            continue
        false_negatives.add(reference)
    return CorrectnessMatrix(
        true_positives=true_positives,
        false_positives=false_positives,
        false_negatives=false_negatives,
    )
